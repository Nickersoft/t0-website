---
import { createMap } from "svg-dotted-map";
import { Path } from "svg-pathgen";
import { cn } from "@/lib/utils";

export interface Connection {
  start: { lat: number; lng: number; label?: string };
  end: { lat: number; lng: number; label?: string };
}

export interface Props {
  width?: number;
  height?: number;
  mapSamples?: number;
  connections?: Connection[];
  dotColor?: string;
  lineColor?: string;
  dotRadius?: number;
  stagger?: boolean;
  class?: string;
}

const {
  width = 152,
  height = 75,
  mapSamples = 5000,
  connections = [],
  dotColor = "currentColor",
  lineColor = "#0ea5e9",
  dotRadius = 0.2,
  stagger = false,
  class: className,
} = Astro.props;

const map = createMap({
  width,
  height,
  mapSamples,
});

// Create curved path helper
function createCurvedPath(
  start: { x: number; y: number },
  end: { x: number; y: number },
): string {
  const midX = (start.x + end.x) / 2;
  const midY = (start.y + end.y) / 2 - height * 0.1;

  return new Path()
    .moveTo(start.x, start.y)
    .curveTo(end.x, end.y, {
      type: "cubic",
      smooth: true,
      control: [midX, midY],
    })
    .toString();
}

function getSteps(points: { x: number; y: number }[]) {
  const sorted = [...points].sort((a, b) => a.y - b.y || a.x - b.x);
  const rowMap = new Map<number, number>();

  let step = 0;
  let prevY = Number.NaN;
  let prevXInRow = Number.NaN;

  for (const p of sorted) {
    if (p.y !== prevY) {
      // new row
      prevY = p.y;
      prevXInRow = Number.NaN;

      if (!rowMap.has(p.y)) {
        rowMap.set(p.y, rowMap.size);
      }
    }

    if (!Number.isNaN(prevXInRow)) {
      const delta = p.x - prevXInRow;

      if (delta > 0) {
        step = step === 0 ? delta : Math.min(step, delta);
      }
    }

    prevXInRow = p.x;
  }

  return { xStep: step || 1, yToRowIndex: rowMap };
}

const { xStep, yToRowIndex } = getSteps(map.points);

const points = map.points.map((point) => {
  const rowIndex = yToRowIndex.get(point.y) ?? 0;
  const staggerX = stagger && rowIndex % 2 === 1 ? xStep / 2 : 0;
  return { ...point, x: point.x + staggerX };
});

const markers = map
  .addMarkers(connections.flatMap(({ end, start }) => [start, end]))
  .map((marker) => {
    const rowIndex = yToRowIndex.get(marker.y) ?? 0;
    const staggerX = stagger && rowIndex % 2 === 1 ? xStep / 2 : 0;
    return { ...marker, x: marker.x + staggerX };
  });

// Prepare canvas data for web component
const canvasData = {
  points,
  width,
  height,
  dotColor,
  dotRadius,
};
---

<div
  class={cn(
    "relative size-full transform-gpu will-change-transform",
    className,
  )}
>
  {/* Canvas for static dots - handled by web component */}
  <dotted-map-canvas
    class="absolute top-0 left-0 size-full overflow-visible text-inherit"
    data-canvas={JSON.stringify(canvasData)}
  >
  </dotted-map-canvas>

  {/* SVG overlay for animated connections - rendered server-side */}
  <svg
    class="pointer-events-none absolute top-0 left-0 size-full overflow-visible"
    viewBox={`0 0 ${width} ${height}`}
  >
    {
      connections.map((_, i) => {
        const idx = i * 2;
        const startMarker = markers[idx];
        const endMarker = markers[idx + 1];

        if (!startMarker || !endMarker) {
          return null;
        }

        return (
          <g>
            <path
              class="connection"
              d={createCurvedPath(startMarker, endMarker)}
              fill="none"
              stroke={lineColor}
              stroke-width={dotRadius / 2}
              data-delay={0.5 * i}
            />
          </g>
        );
      })
    }

    {
      markers.map((marker) => (
        <g>
          <circle cx={marker.x} cy={marker.y} r={dotRadius} fill={lineColor} />
          <circle
            cx={marker.x}
            cy={marker.y}
            r={dotRadius}
            fill={lineColor}
            opacity="0.5"
          >
            <animate
              attributeName="r"
              from={dotRadius}
              to={dotRadius * 4}
              dur="1.5s"
              begin="0s"
              repeatCount="indefinite"
            />
            <animate
              attributeName="opacity"
              from="0.5"
              to="0"
              dur="1.5s"
              begin="0s"
              repeatCount="indefinite"
            />
          </circle>
        </g>
      ))
    }
  </svg>
</div>

<script>
  import { animate, stagger } from "motion/react";

  interface CanvasData {
    points: Array<{ x: number; y: number }>;
    width: number;
    height: number;
    dotColor: string;
    dotRadius: number;
  }

  class DottedMapCanvas extends HTMLElement {
    private canvas: HTMLCanvasElement | null = null;
    private resizeObserver: ResizeObserver | null = null;
    private canvasData: CanvasData | null = null;

    connectedCallback() {
      const dataAttr = this.getAttribute("data-canvas");

      if (!dataAttr) return;

      this.canvasData = JSON.parse(dataAttr);
      this.canvas = document.createElement("canvas");
      this.canvas.className = "size-full";
      this.appendChild(this.canvas);

      this.updateCanvas();

      this.resizeObserver = new ResizeObserver(() => this.updateCanvas());
      this.resizeObserver.observe(this);
    }

    disconnectedCallback() {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
    }

    private updateCanvas() {
      if (!this.canvas || !this.canvasData) return;

      const ctx = this.canvas.getContext("2d");

      if (!ctx) return;

      const rect = this.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;

      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      ctx.scale(dpr, dpr);

      const scale = Math.min(
        rect.width / this.canvasData.width,
        rect.height / this.canvasData.height,
      );

      const scaleX = scale;
      const scaleY = scale;
      const offsetX = (rect.width - this.canvasData.width * scale) / 2;
      const offsetY = (rect.height - this.canvasData.height * scale) / 2;

      let fillColor = this.canvasData.dotColor;

      if (fillColor === "currentColor") {
        fillColor = getComputedStyle(this).color;
      }

      ctx.fillStyle = fillColor;

      this.canvasData.points.forEach((point) => {
        ctx.beginPath();

        ctx.arc(
          point.x * scaleX + offsetX,
          point.y * scaleY + offsetY,
          this.canvasData!.dotRadius * scaleX,
          0,
          Math.PI * 2,
        );
        ctx.fill();
      });
    }
  }

  function animatePaths() {
    const paths = document.querySelectorAll(".connection");

    animate(
      paths,
      { pathLength: [0, 1] },
      { duration: 1, delay: stagger(0.2), ease: "easeOut" },
    );
  }

  if (!customElements.get("dotted-map-canvas")) {
    customElements.define("dotted-map-canvas", DottedMapCanvas);
  }

  animatePaths();
</script>
